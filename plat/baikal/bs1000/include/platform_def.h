/*
 * Copyright (c) 2020-2023, Baikal Electronics, JSC. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#ifndef PLATFORM_DEF_H
#define PLATFORM_DEF_H

#include <arch.h>
#include <plat/common/common_def.h>

#ifdef IMAGE_BL1
# define PLATFORM_STACK_SIZE		U(0x800)
#else
# define PLATFORM_STACK_SIZE		U(0x2000)
#endif

#define PLATFORM_MAX_CPUS_PER_CLUSTER	U(4)
#define PLATFORM_CLUSTER_COUNT		U(12)
#define PLATFORM_CORE_COUNT_PER_CLUSTER	PLATFORM_MAX_CPUS_PER_CLUSTER
#define PLATFORM_CORE_COUNT_PER_CHIP	(PLATFORM_CLUSTER_COUNT * \
					 PLATFORM_CORE_COUNT_PER_CLUSTER)
#define PLATFORM_CORE_COUNT		(PLATFORM_CHIP_COUNT * \
					 PLATFORM_CORE_COUNT_PER_CHIP)

#define PLAT_NUM_PWR_DOMAINS		(PLATFORM_CHIP_COUNT * \
					 (PLATFORM_CLUSTER_COUNT + \
					  PLATFORM_CORE_COUNT_PER_CHIP))

#define PLAT_MAX_PWR_LVL		MPIDR_AFFLVL1
#define PLAT_MAX_RET_STATE		U(1)
#define PLAT_MAX_OFF_STATE		U(2)

/* Local power state for power domains in Run state */
#define PLAT_LOCAL_STATE_RUN		U(0)
/* Local power state for retention. Valid only for CPU power domains */
#define PLAT_LOCAL_STATE_RET		U(1)
/* Local power state for power-down. Valid for CPU and cluster power domains */
#define PLAT_LOCAL_STATE_OFF		U(2)

/*
 * Macros used to parse state information from State-ID if it is using the
 * recommended encoding for State-ID.
 */
#define PLAT_LOCAL_PSTATE_WIDTH		U(4)
#define PLAT_LOCAL_PSTATE_MASK		((U(1) << PLAT_LOCAL_PSTATE_WIDTH) - 1)

/* Chip address space offset */
#define PLATFORM_CHIP_MEM_OFFSET(chip)	\
		((ULL(1) << PLATFORM_ADDR_BITS_PER_CHIP) * (chip))

/* Physical and virtual address space limits */
#define PLAT_PHY_ADDR_SPACE_SIZE	PLATFORM_CHIP_MEM_OFFSET(PLATFORM_CHIP_COUNT)
#define PLAT_VIRT_ADDR_SPACE_SIZE	PLATFORM_CHIP_MEM_OFFSET(PLATFORM_CHIP_COUNT)

/* Convert local chip address into global address space */
#define PLATFORM_ADDR_OUT_CHIP(chip, addr)	\
		(PLATFORM_CHIP_MEM_OFFSET(chip) + (addr))

/* Convert global address into local chip address space */
#define PLATFORM_ADDR_IN_CHIP(addr)	\
		((addr) & (PLATFORM_CHIP_MEM_OFFSET(1) - 1))

/* Get chip number owned address */
#define PLATFORM_ADDR_CHIP(addr)	((addr) >> PLATFORM_ADDR_BITS_PER_CHIP)

#define CACHE_WRITEBACK_SHIFT		U(6)
#define CACHE_WRITEBACK_GRANULE		(U(1) << CACHE_WRITEBACK_SHIFT)

#ifdef MULTICHIP_SYSTEM_COUNTERS_RESYNC
#define MAX_INTR_EL3			1
#define MAX_DW_APB_TIMERS		1
#define MAX_MMAP_REGIONS		(19 + ((PLATFORM_CHIP_COUNT - 1) * 10))
#define MAX_XLAT_TABLES			(14 + ((PLATFORM_CHIP_COUNT - 1) * 9))
#else
#define MAX_MMAP_REGIONS		(17 + ((PLATFORM_CHIP_COUNT - 1) * 9))
#define MAX_XLAT_TABLES			(13 + ((PLATFORM_CHIP_COUNT - 1) * 9))
#endif
#define MAX_IO_DEVICES			3
#define MAX_IO_HANDLES			6

/* Partition memory into secure ROM, non-secure DRAM, secure "SRAM", and secure DRAM */
#define NS_DRAM0_BASE			0x80000000
#define NS_DRAM0_SIZE			0x10000000

#define SEC_DRAM_BASE			0x90000000
#define SEC_DRAM_SIZE			0x1000000

#define NS_DRAM1_BASE			0xa0000000
#define NS_DRAM1_SIZE			0x20000000

#define BL1_RO_BASE			0
#define BL1_RO_LIMIT			0xe000
#define BL1_RW_BASE			BL1_RO_LIMIT
#define BL1_RW_LIMIT			0x1f000
#define SCP_SERVICE_BASE		0x1ffe0
#define BL2_BASE			BAIKAL_FIP_LIMIT
#define BL2_SIZE			0x22000
#define BL2_LIMIT			(BL2_BASE + BL2_SIZE)
#define BL31_BASE			BL2_LIMIT
#define BL31_SIZE			(0x100000 + (0x4000 * PLATFORM_CHIP_COUNT))
#define BL31_LIMIT			(BL31_BASE + BL31_SIZE)

#define BAIKAL_TRUSTED_MAILBOX_BASE	BL1_RW_BASE
#define BAIKAL_TRUSTED_MAILBOX_SIZE	(8 + BAIKAL_HOLD_SIZE)
#define BAIKAL_HOLD_BASE		(BAIKAL_TRUSTED_MAILBOX_BASE + 8)
#define BAIKAL_HOLD_SIZE		(PLATFORM_CORE_COUNT * BAIKAL_HOLD_ENTRY_SIZE)
#define BAIKAL_HOLD_ENTRY_SIZE		8
#define BAIKAL_HOLD_STATE_WAIT		0
#define BAIKAL_HOLD_STATE_GO		1

#define BL1_XLAT_BASE			SEC_DRAM_BASE
#define BL1_XLAT_SIZE			0x10000

#define BAIKAL_SCMM_SMMU_BASE		(SEC_DRAM_BASE + BL1_XLAT_SIZE)
#define BAIKAL_SCMM_SMMU_SIZE		0x1000
#define BAIKAL_SCMM_SMMU_STRTAB_BASE	BAIKAL_SCMM_SMMU_BASE
#define BAIKAL_SCMM_SMMU_STRTAB_LOG2SIZE	4
#define BAIKAL_SCMM_SMMU_STRTAB_SIZE	(1 << (BAIKAL_SCMM_SMMU_STRTAB_LOG2SIZE + 6))
#define BAIKAL_SCMM_SMMU_CMDQ_BASE	(BAIKAL_SCMM_SMMU_STRTAB_BASE + BAIKAL_SCMM_SMMU_STRTAB_SIZE)
#define BAIKAL_SCMM_SMMU_CMDQ_LOG2SIZE	5
#define BAIKAL_SCMM_SMMU_CMDQ_SIZE	(1 << (BAIKAL_SCMM_SMMU_CMDQ_LOG2SIZE + 4))
#define BAIKAL_SCMM_SMMU_EVENTQ_BASE	(BAIKAL_SCMM_SMMU_CMDQ_BASE + BAIKAL_SCMM_SMMU_CMDQ_SIZE)
#define BAIKAL_SCMM_SMMU_EVENTQ_LOG2SIZE	5
#define BAIKAL_SCMM_SMMU_EVENTQ_SIZE	(1 << (BAIKAL_SCMM_SMMU_EVENTQ_LOG2SIZE + 4))

#define BAIKAL_FIP_BASE			(BAIKAL_SEC_DTB_BASE + BAIKAL_DTB_MAX_SIZE)
#define BAIKAL_FIP_LIMIT		(BAIKAL_FIP_BASE + BAIKAL_FIP_MAX_SIZE)

#define BAIKAL_SEC_DTB_BASE		(BAIKAL_SCMM_SMMU_BASE + BAIKAL_SCMM_SMMU_SIZE)
#define BAIKAL_NS_DTB_BASE		NS_DRAM0_BASE
#define BAIKAL_NS_IMAGE_OFFSET		NS_DRAM1_BASE
#define BAIKAL_NS_IMAGE_MAX_SIZE	NS_DRAM1_SIZE

/* Parts of the boot image */
#define BAIKAL_SCP_MAX_SIZE		(512 * 1024)
#define BAIKAL_BL1_MAX_SIZE		(256 * 1024)
#ifdef BAIKAL_MBS_2S
#define BAIKAL_DTB_MAX_SIZE		(768 * 1024)
#else
#define BAIKAL_DTB_MAX_SIZE		(256 * 1024)
#endif
#define BAIKAL_VAR_MAX_SIZE		(768 * 1024)
#define BAIKAL_FIP_MAX_SIZE		(BAIKAL_FAT_OFFSET - BAIKAL_BL1_MAX_SIZE - BAIKAL_DTB_MAX_SIZE - BAIKAL_VAR_MAX_SIZE)

#define BAIKAL_BL1_OFFSET		0
#define BAIKAL_DTB_OFFSET		(BAIKAL_BL1_OFFSET + BAIKAL_BL1_MAX_SIZE)
#define BAIKAL_TFW_OFFSET		(BAIKAL_DTB_OFFSET + BAIKAL_DTB_MAX_SIZE - 128 * 1024)
#define BAIKAL_VAR_OFFSET		(BAIKAL_DTB_OFFSET + BAIKAL_DTB_MAX_SIZE)
#define BAIKAL_FIP_OFFSET		(BAIKAL_VAR_OFFSET + BAIKAL_VAR_MAX_SIZE)
#define BAIKAL_FAT_OFFSET		(8 * 1024 * 1024)

#endif /* PLATFORM_DEF_H */
